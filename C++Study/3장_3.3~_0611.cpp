/// 3.3 코드 분할
// 코드 분할이란 코드를 더 작은 단위로 나눠서 작성하는 방식이다. 소스 코드 파일을 열어보니 수백 줄에 달하는
// 함수들로 가득 차 있고, 수많은 블록이 복잡하게 중첩돼 있는 것을 보면 가슴이 꽉 막히는 기분이 들 것이다.
// 가장 바람직한 형태는 함수나 메서드마다 한 가지 작업만 수행하는 것이다. 한 작업을 처리하는 데 필요한 부분 작업이
// 상당히 복잡하면 이를 별도의 함수나 메서드로 분할한다.

// 3.3.1 리팩토링을 통한 코드 분할
// 프로그래밍을 하다 보면 몰입 상태에 빠진 채 엄청난 속도로 코드를 작성할 때가 있다.
// 그런데 이렇게 작업한 결과를 보면 의도한 기능은 제대로 동작하지만, 작성된 코드의 스타일은 형편없는 경우가 많다.
// 프로그래머라면 누구나 한번쯤 이런 경험을 해봤을 것이다. 이렇게 짧은 시간에 엄청난 양의 코드를 작성할 때가 전체
// 프로젝트 기간 중에서도 가장 생산성이 높은 시점이기도 하다. 하지만 이렇게 작성된 코드를 바탕으로 수정 작업을
// 하다 보면 금세 코드가 빽빽해진다. 여기에 새로운 요구사항이나 버그 픽스가 들어오면서 기존 코드에 자잘하게 
// 덧붙이는 부분이 늘어난다. 이렇게 자잘한 코드가 누적되면서 원래 세련됐던 코드가 패치나 특수한 경우를 처리하는
// 코드로 뒤덮이게 되는 것을 흔히 **누더기**가 됐다고 표현한다.

// **리팩토링**이란 코드의 구조를 재조정하는 작업이다. 코드를 리팩토링하는 데 사용하는 기법의 예로 다음과
// 같은 것들이 있다.
// 추상화 수준을 높이는 기법
//		- 필드 캡슐화 : 필드를 private으로 설정하고, 게터나 세터 메서드로 접근하게 만든다.
//		- 타입 일반화 : 코드를 좀 더 공유할 수 있도록 좀 더 일반적인 타입을 사용한다.
// 코드를 좀 더 논리적으로 분할하는 기법
//		- 메서드 추출 : 거대한 메서드를 좀 더 이해하기 쉽도록 일부를 뽑아내서 새로운 메서드로 정의한다.
//		- 클래스 추출 : 기존 클래스에 있는 코드 중 일부를 새 클래스로 옮긴다.
// 명칭과 위치를 개선하는 기법
//		- 메서드 및 필드 이동 : 좀 더 적합한 클래스나 소스 파일로 이동한다.
//		- 메서드 및 필드 이름 변경 : 목적이 잘 드러나도록 이름을 바꾼다.
//		- 올리기 : OOP에서 기본(base) 클래스로 옮기는 기법
//		- 내리기 : OOP에서 상속(derived) 클래스로 옮기는 기법

// 코드를 처음부터 읽기 힘든 누더기로 작성했거나 원래는 깔끔했는데 갈수록 누더기로 변했다면 주기적으로
// 리팩토링해서 임시방편으로 작성한 코드를 제거해야 한다. 리팩토링을 수행할 때 기존 코드를 다시 검토해서
// 이해하고 유지하기 쉬운 형태로 변환한다. 리팩토링은 코드 분할을 수행할 좋은 기회이기도 하다.
// 코드의 목적이 변경됐거나 지금껏 한 번도 분할한 적이 없다면 눈을 가늘게 뜨고 코드의 개략적인 모양새를
// 훑어보면서 더 작은 단위로 분할할 필요가 있는지 판단한다.

// 3.3.2 디자인 기준으로 코드 분할하기
// 프로그램을 구현할 때 모든 기능을 빠짐없이 코드로 작성하지 말고, 코드 분할 기법을 적용해서 나중에
// 모듈, 메서드, 함수에서 구현할 부분을 따로 빼놓는 방식으로 작성하면 코드의 밀집도를 낮추고 구조를
// 좀 더 체계적으로 만들 수 있다.
// 그리고 당연한 말이지만 곧바로 코드부터 작성하지 말고 **먼저** 프로그램 디자인부터 해야 한다.

/// 3.4 명명 규칙
// c++ 컴파일러는 다음과 같은 명명 규칙을 따른다.
// - 이름의 첫 글자로 숫자가 나올 수 없다(예 : 9to5)
// - 더블 언더스코어는 특정한 용도로 사용되기 때문에 이름에 넣을 수 없다(예 : my__name)
// - 언더스코어로 시작하는 이름도 특정한 용도로 사용하기 때문에 쓸 수 없다(예 : _name, _Name)
