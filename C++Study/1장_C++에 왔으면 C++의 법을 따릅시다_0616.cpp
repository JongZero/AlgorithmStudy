/// 1장 C++에 왔으면 C++의 법을 따릅시다.
/// 항목 1 : C++를 언어들의 연합체로 바라보는 안목은 필수
// C++를 단일 언어로 바라보는 눈을 넓혀, 상관 관계가 있는 여러 언어들의 연합체(federation)으로 보자.
// C++를 제대로 따라잡으려면, 이 언어가 여러 개의 하위 언어(sublanguage)를 제공한다는 점을 새기고 있어야 한다.
// 하위 언어는 아래의 네 가지이다.
// C : C++는 여전히 C를 기본으로 하고 있다. 블록, 문장, 선행 처리자, 기본제공 데이터타입, 배열, 포인터 등
// 모든 것이 C에서 왔다.
// 객체 지향 개념의 C++ : 이 부분에 '클래스를 쓰는 C'에 관한 것이 모두 해당된다.
// 그러니까 클래스(생성자와 소멸자 개념까지), 캡슐화, 상속, 다형성, 가상 함수(동적 바인딩)등이다.
// 템플릿 C++ : C++의 일반화 프로그래밍 부분이다. 템플릿의 주체 못할 강력함이 너무나도 크고 훌륭하다 보니
// 완전히 새로운 프로그래밍 패러다임이 파생되기까지 했다. 이름하여 템플릿 메타프로그래밍(template metaprogramming: TMP)이다.
// STL : STL은 이름에서 알 수 있듯이 템플릿 라이브러리이다. 하지만 대단히 특별한 템플릿 라이브러리라고 말할 수 있다.
// STL의 세계는 컨테이너(container), 반복자(iterator), 알고리즘(algorithm)과 함수 객체(function object)가 만수산 드렁칡처럼
// 얽혀 돌아가는 것을 규칙으로 삼고 있으나, 템플릿과 라이브러리는 얼마든지 다른 아이디어를 중심으로 만들어질 수 있다. 또한 STL은
// 나름대로 독특한 사용규약이 있어서, STL을 써서 프로그래밍하려면 그 규약을 따르면 된다.

// 이것만은 잊지 말자!
// C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라진다.
// 그 경우란, 바로 C++의 어떤 부분을 사용하느냐이다.

/// 항목 2 : #define을 쓰려거든 const, enum, inline을 떠올리자
// "가급적 선행 처리자보다 컴파일러를 더 가까이 하자"

// 아래와 같은 코드를 썼다고 가정해보자.
#define ASPECT_RATIO 1.653
// 우리에겐 ASPECT_RATIO가 기호식 이름(symbolic name)으로 보이지만 컴파일러에겐 전혀 보이지 않는다.
// 컴파일러에게 넘어가기 전에 선행 처리자가 밀어버리고 숫자 상수로 바꾸어 버리기 때문이다.
// 그 결과로, ASPECT_RATIO라는 이름은 컴파일러가 쓰는 기호 테이블에 들어가지 않는다.
// 그래서 숫자 상수로 대체된 코드에서 컴파일 에러라도 발생하게 되면 꽤나 헷갈릴 수 있다.
// 소스 코드엔 분명히 ASPECT_RATIO가 있었는데 에러 메시지엔 1.653이 있으니깐 말이다.

// 이런 문제의 해결법은 매크로 대신 상수를 쓰는 것이다.
const double AspectRatio = 1.653;	// 대문자로만 표기하는 이름은 대개 매크로에 쓰는 것이어서,
									// 이름 표기도 바꾼다.
// AspectRatio는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 당연히 컴파일러의 눈에도 보이며
// 기호 테이블에도 당연히 들어간다.
// 게다가 (위의 예제처럼) 상수가 부동소수점 실수 타입일 경우에는 컴파일을 거친 최종 코드의 크기가 #define을 썼을 때보다
// 작게 나올 수 있다.
// 매크로를 쓰면 코드에 ASPECT_RATIO가 등장하기만 하면 선행 처리자에 의해 1.653으로 모두 바뀌면서 결국
// 목적 코드 안에 1.653의 사본이 등장 횟수만큼 들어가게 되지만, 상수 타입의 AspectRatio는 아무리 여러 번 쓰이더라도
// 사본은 딱 한 개만 생기기 때문이다.

// #define을 상수로 교체할 때는 다음을 특별히 조심하자.
// 상수 포인터(constant pointer)를 정의하는 경우
// 상수 정의는 대개 헤더 파일에 넣는 것이 상례이므로(다른 소스 파일이 이것을 인클루드해서 쓰게 되므로) 포인터(pointer)는 꼭
// const로 선언해 주어야 하고, 이와 아울러 포인터가 가리키는 대상까지 const로 선언하는 것이 보통이다.
// 이를테면 어떤 헤더 파일 안에 char* 기반의 문자열 상수를 정의한다면 다음과 같이 const를 **두 번** 써야 한다는 말이다.
// const와 포인터가 함께 쓰일 경우에 대한 내용은 항목 3을 참고하자.
const char* const authorName = "Scott Meyers";

#include <string>
// 문자열 상수를 쓸 때 위와 같이 char* 기반의 구닥다리 문자열보다는 string 객체가 대체적으로 사용하기 괜찮다.
//const std::string authorName("Scott Meyers");

// 2. 클래스 멤버로 상수를 정의하는 경우, 즉 클래스 상수를 정의하는 경우
// 어떤 상수의 유효범위를 클래스로 한정하고자 할 때는 그 상수를 멤버로 만들어야 하는데,
// 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 정적(static) 멤버로 만들어야 한다.
// 다음을 보자.
//class GamePlayer
//{
//private:
//	static const int NumTurns = 5;		// 상수 선언
//	int scores[NumTurns];				// 상수를 사용하는 부분
//};

// 다음도 가능하다.
class GamePlayer
{
private:
	enum { NumTurns = 5 };		// "나열자 둔갑술" : NumTurns를
								// 5에 대한 기호식 이름으로 만든다.

	int scores[NumTurns];		// 사용하는 부분
};
// 위와 같은 방법을 '나열자 둔갑술(enum hack)'이라고 부른다.
// 나열자 둔갑술은 알아 두는 것이 2가지 이유로 피가 되고 살이 된다.
// 1. 나열자 둔갑술은 동작 방식이 const보다는 #define에 더 가깝다.
// 여러분이 선언한 정수 상수를 가지고 다른 사람이 주소를 얻는다든지
// 참조자를 쓴다든지 하는 것이 싫다면 enum이 아주 좋은 자물쇠가 될 수 있다.
// enum은 #define처럼 어떤 형태의 쓸데없는 메모리 할당도 절대 저지르지 않는다.

// 2. 실용적인 이유로, 상당히 많은 코드에서 이 기법이 쓰이고 있기 때문에 알면 좋다.
// 이 나열자 둔갑술은 템플릿 메타프로그래밍의 핵심 기법이기도 하다. (항목 48 참조)

// 다음은 매크로 함수를 보자.
// 매크로 함수는 함수처럼 보이지만 함수 호출 오버헤드를 일으키지 않는 매크로다.
// 다음의 예를 보자. 매크로 인자들 중 큰 것을 사용해서 어떤 함수 f를 호출하는 매크로다.
// a와 b 중에 큰 것을 f에 넘겨 호출한다.
#define CALL_WITH_MAX(a, b) int f((a) > (b) ? (a) : (b))
// 이런 식의 매크로는 단점이 한두 개가 아니다.
// 이런 매크로를 작성할 때는 매크로 본문에 들어 있는 인자마다 반드시 괄호를 씌워 주는 센스를 잊지 말아야 한다.
// 이게 안 되어 있으면, 표현식을 매크로에 넘길 때 골치 아픈 일이 발생할 수 있다.
// 그런데 이 부분을 제대로 처리한다고 해서 끝난 것일까? 괴현상을 일으키는 다음 예를 보자.
int a = 5, b = 0;
CALL_WITH_MAX(++a, b);			// a가 두 번 증가한다.
CALL_WITH_MAX(++a, b + 10);		// a가 한 번 증가한다.
// f가 호출되기 전에 a가 증가하는 횟수가 달라진다.
// 비교를 통해 처리한 결과가 어떤 것이냐에 따라 달라지는 것이다.

// C++에서는 함수 호출을 없애 준다는 명목 하에 자행되는 이런 어처구니없는 작태를 참을 필요가 없다.
// 기존 매크로의 효율을 그대로 유지함은 물론 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽히 취할 수 있는 방법이
// 있기 때문이다.
// 바로, 인라인 함수에 대한 템플릿을 준비하는 것이다.
template<typename T>								// T가 정확히 무엇인지
inline void callWithMax(const T& a, const T& b)		// 모르기 때문에, 매개변수로
{													// 상수 객체에 대한 참조자를
	f(a > b ? a : b);								// 쓴다. 항목 20 참조
}
// 이 함수는 템플릿이기 때문에 동일 계열 함수군(family of functions)을 만들어낸다.
// 동일한 타입의 객체 두 개를 인자로 받고 둘 중 큰 것을 f에 넘겨서 호출하는 구조다.
// 보면 알겠지만 함수 본문에 괄호로 분칠을 해 댈 필요가 없고, 인자를 여러 번 평가할지도
// 모른다는 걱정도 없어진다. 그뿐 아니라 callWithMax는 진짜 함수이기 때문에 유효범위 및
// 접근 규칙을 그대로 따라간다.

// 이것만은 잊지 말자!
// - 단순한 상수를 쓸 때는, #define보다 const 객체 혹은 enum을 우선 생각하자
// - 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각하자.

/// 항목3 : 낌새만 보이면 const를 들이대 보자!
// const의 면모에 대해 생각해 볼 때 정말 멋지다고 말할 수 있는 부분이 있다면 아마도
// '의미적인 제약'(const가 붙은 객체는 외부 변경을 **불가능**하게 한다)을 소스 코드 수준에서
// 붙인다는 점과 컴파일러가 이 제약을 단단히 지켜준다는 점일 것이다.
// 어떤 값(객체의 내용)이 불변이어야 한다는 제작자의 의도를 컴파일러 및 다른 프로그래머와 나눌 수 있는
// 수단이라고나 할까?

// const 키워드는 그야말로 팔방미인이다.
// 클래스 바깥에서는 전역 혹은 네임스페이스 유효범위의 상수를 선언(정의)하는 데 쓸 수 있다.
// 그뿐 아니라 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const를 붙일 수 있다.
// 클래스 내부의 경우에는, 정적 멤버 및 비정적 데이터 멤버 모두를 상수로 선언할 수 있다.

// 포인터는 어떨까? 기본적으로 포인터 자체를 상수로, 혹은 포인터가 가리키는 데이터를 상수로
// 지정할 수 있는데, 둘 다 지정할 수도 있고 아무것도 지정하지 않을 수도 있다.
// 다음을 보자.
char greeting[] = "Hello";

char* p = greeting;					// 비상수 포인터,
									// 비상수 데이터

const char* p = greeting;			// 비상수 포인터,
									// 상수 데이터

char* const p = greeting;			// 상수 포인터,
									// 비상수 데이터

const char* const p = greeting;		// 상수 포인터,
									// 상수 데이터
// const 키워드가 *표의 왼쪽에 있으면 포인터가 가리키는 대상이 상수인 반면,
// const가 *표의 오른쪽에 있는 경우엔 포인터 자체가 상수다. const가 *표의 양쪽에
// 다 있으면 포인터가 가리키는 대상 및 포인터가 다 상수라는 뜻이다.

struct Widget {};

// 아래의 함수들이 받아들이는 매개변수 타입은 모두 똑같다.
void f1(const Widget* pw);		// f1은 상수 Widget 객체에 대한
								// 포인터를 매개변수로 취한다.
void f2(Widget const* pw);		// f2도 마찬가지다.

// STL 반복자(iterator)는 포인터를 본뜬 것이기 때문에,
// 기본적인 동작 원리가 T* 포인터와 매우 흡사하다.
// 어떤 반복자를 const로 선언하는 일은 포인터를 상수로 선언하는 것(즉, T* const 포인터)과 같다.
// 반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않지만,
// 반복자가 가리키는 대상 자체는 변경이 가능하다. 만약 변경이 불가능한 객체를 가리키는 반복자
// (즉, const T* 포인터의 STL 대응물)가 필요하다면 const_iterator를 쓰면 된다.
#include <vector>


int main()
{
	std::vector<int> vec;
	const std::vector<int>::iterator iter = vec.begin();

	for (const std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++)
	{
		*it = 10;
		++it;
	}

	for (auto it : vec)
	{
		it = 10;
	}

	// iter는 T* const처럼 동작한다.
	*iter = 10;		// OK, iter가 가리키는 대상을 변경한다.
	++iter;			// 에러! iter는 상수다.

	std::vector<int>::const_iterator cIter = vec.begin();
	// cIter는 const T*처럼 동작한다.
	*cIter = 10;	// 에러! *cIter가 상수이기 때문에 안된다.
	++cIter;		// 이건 문제없다. cIter를 변경하기 때문
}

// 가장 강력한 const의 용도는 함수 선언에 쓸 경우이다.
// 함수 선언문에 있어서 const는 함수 반환 값, 각각의 매개변수, 멤버 함수 앞에 붙을 수 있고, 함수 전체에 대해 const의 성질을 붙일 수 있다.
// 함수 반환 값을 상수로 정해 주면, 안전성이나 효율을 포기하지 않고도 사용자측의 에러 돌발 상황을 줄이는 효과를 꽤 자주 볼 수 있게 된다.
// 다음 예를 보자.
class Rational { ... };

const Rational operator*(const Rational& lhs, const Rational& rhs);
// 만약 operator*의 반환 값이 상수 객체가 아니라면 사용자 쪽에서 저지르는 아래와 같은 어처구니 없는 실수를 멍청히 지켜볼 수밖에 없다.
Rational a, b, c;
...
(a* b) = c;			// a*b의 결과에 대고
					// operator=를 호출하다니!

// 다음의 경우도 있을 수 있다.
if (a * b = c) ...		// 비교하려고 했던 건데!


// 위에서 본 바와 같이 두 수의 곱에 대해 대입 연산이 되도록 놓아두는 것은 '쓸데없는' 경우다.
// operator*의 반환 값을 const로 정해 놓으면 이런 경우를 미연에 막을 수 있다.
// 그렇기 때문에 상수 반환 값 지정이 정답이 되는 것이다.

// <상수 멤버 함수>
// 멤버 함수에 붙은 const 키워드의 역할은 "해당 멤버 함수가 상수 객체에 대해 호출될 함수이다"라는 사실을
// 알려 주는 것이다. 그런데 이런 함수가 왜 중요할까? 이유는 두 가지이다.
// 1. 클래스의 인터페이스를 이해하기 좋게 하기 위해서이다.
// 즉, 그 클래스로 만들어진 객체를 변경할 수 있는 함수는 무엇이고, 또 변경할 수 없는 함수는 무엇인가를 사용자 쪽에서
// 알고 있어야 하는 것이다.
// 2. 이 키워드를 통해 상수 객체를 사용할 수 있게 하기 위해서이다.
// 이것은 코드의 효율을 위해 아주 중요한 부분이다. 항목 20에서 이야기하고 있듯이 C++ 프로그램의 실행 성능을 높이는
// 핵심 기법 중 하나가 객체 전달을 '상수 객체에 대한 참조자(reference-to-const)'로 진행하는 것이기 때문이다.
// 그런데 이 기법이 제대로 살아 움직이려면 상수 상태로 전달된 객체를 조작할 수 있는 const 멤버 함수, 즉 상수 멤버 함수가
// 준비되어 있어야 한다는 것이 바로 포인트다.

// const 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능하다.
// 이것은 C++의 아주 중요한 성질이니 꼭 외워두자.
// 한 예로, 문서의 한 구역을 나타내는 데 쓰려고 만든 클래스를 보자.
class TextBlock
{
public:
	...
	const char& operator[](std::size_t position) const	// 상수 객체에 대한
	{ return text[position]; }							// operator[]

	char& operator[](std::size_t position)				// 비상수 객체에 대한
	{ return text[position]; }							// operator[]

private:
	std::string text;
};

// 위처럼 선언된 TextBlock의 operator[]는 다음과 같이 쓸 수 있다.
TextBlock tb("Hello");
std::cout << tb[0];				// TextBlock::operator[]의
								// 비상수 멤버를 호출한다.
const TextBlock ctb("World");	// TextBlock::operator[]의
std::cout << ctb[0];			// 상수 멤버를 호출한다.

// 참, 실제 프로그램에서 상수 객체가 생기는 경우는 (1) 상수 객체에 대한 포인터 혹은
// (2) 상수 객체에 대한 참조자로 객체가 전달될 때다. 위의 ctb 예제는 이해를 돕기 위한
// 용도의 성격이 짙고, 아래의 예제가 더 실제의 경우와 가깝다.
void print(const TextBlock& ctb)// 이 함수에서 ctb는 상수 객체로 쓰인다.
{
	std::cout << ctb[0];		// TextBlock::operator[]의
								// 상수 멤버를 호출한다.
}

// operator[]를 '오버로드(overload)'해서 각 버전마다 반환 타입을 다르게 가져갔기 때문에,
// TextBlock의 상수 객체와 비상수 객체의 쓰임새가 달라진다.
std::cout << tb[0];		// 좋다. 비상수 버전의 TextBlock 객체를 읽는다.
tb[0] = 'x';			// 문제없다. 비상수 버전의 TextBlock 객체를 쓴다.
std::cout << ctb[0];	// 문제없다. 상수 버전의 TextBlock 객체를 읽는다.
ctb[0] = 'x';			// 컴파일 에러! 상수 버전의 TextBlock 객체에 대해 쓰기는 안 된다.
// 주의할 것이 하나 있는데, 넷째 줄에서 발생한 에러는 순전히 operator[]의 **반환 타입(return type)**
// 때문에 생긴 것이란 점이다. 그러니까 operator[] 호출이 잘못된 것은 아니다. 이 에러는
// const char& 타입에 대입 연산을 시도했기 때문에 생긴 것이다.
// 상수 멤버로 되어 있는 operator[]의 반환 타입이 const char&이기 때문이다.

// 하나 더 눈여겨 볼 부분이 있다. operator[]의 비상수 멤버는 char의 **참조자(reference)**를
// 반환한다는 것인데, char 하나만 쓰면 안 된다는 점을 꼭 주의하자. 만약 operator[]가 그냥
// char를 반환하게 만들어져 있으면, 다음과 같은 문장이 컴파일되지 않게 됩니다.
tb[0] = 'x';
// 왜 그럴까? 기본제공 타입을 반환하는 함수의 반환 값을 수정하는 일은 절대로 있을 수 없기 때문이다.
// 설령 이것이 합법적으로 통한다고 해도, 반환 시 '값에 의한 반환'을 수행하는 C++의 성질(항목 20 참조)이 뒤에
// 떡 버티고 있다.
// 즉, 수정되는 값은 tb.text[0]의 사본이지, tb.text[0] 자체가 아니라는 것이다.
// 아마 이게 여러분이 의도한 동작은 아닐 것이다.

// 다음은 어떤 멤버 함수가 상수 멤버(const)라는 것이 대체 어떤 의미인지 알아보자.
// 여기에는 굵직한 양대 개념이 자리 잡고 있다. 그 개념은 다음과 같다.
// - 비트 수준 상수성(bitwise constness), 다른 말로 물리적 상수성(physical constness)
// - 논리적 상수성
// 비트 수준 상수성은 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야(정적 멤버는 제외) 그 멤버 함수가
// 'const'임을 인정하는 개념이다. 즉, 그 객체를 구성하는 비트들 중 어떤 것도 바꾸면 안 된다는 것이다.
// C++에서 정의하고 있는 상수성이 비트수준 상수성이다. 그리고 상수 멤버 함수는 그 함수가 호출된 객체의 어떤 비정적 멤버도
// 수정할 수 없게 되어있다.

// 그런데, 애석하게도 '제대로 const'로 동작하지 않는데도 이 비트수준 상수성 검사를 통과하는 멤버 함수들이 적지 않다.
// 어떤 포인터가 **가리키는 대상**을 수정하는 멤버 함수들 중 상당수가 이런 경우에 속한다.
// 하지만 그 **포인터**가 객체의 멤버로 들어 있는 한, 이 함수는 비트수준 상수성을 갖는 것으로 판별되고 컴파일러도 뭐라고 하지 않는다.
// 그런데 이것 때문에 상식적으로 이해가 안 되는 동작이 생길 수 있다.
// 다음과 같이 TextBlock 클래스에서 내부 데이터를 string 대신 char*로 관리하는 클래스를 봐보자.
class CTextBlock
{
public:
	...
	char& operator[](std::size_t position) const	// 부적절한(그러나 비트수준
	{ return pText[position]; }						// 상수성이 있어서 허용되는
													// operator[]의 선언
private:
	char* pText;
};
// 코드에 나와 있듯이 operator[] 함수가 상수 멤버 함수로 선언되어 있다. (틀린 건데 말이다)
// 이 함수는 그럼에도 불구하고 해당 객체의 내부 데이터에 대한 참조자를 버젓이 반환한다.
// 이건 일단 그렇다 치고 operator[]의 내부 코드만 보면 pText는 안 건드린다는 점은 확실하다.
// 그러니 컴파일러가 이 operator[]에 대한 코드를 생성할 때 불평하지 않는 것이다.
// 하지만 이로 인해 다음과 같은 문제가 생긴다.
const CTextBlock cctb("Hello");		// 상수 객체를 선언
char* pc = &cctb[0];				// 상수 버전의 operator[]를 호출하여 cctb의
									// 내부 데이터에 대한 포인터를 얻는다.
*pc = 'J';							// cctb는 이제 "Jello"라는 값을 갖는다.
// 확실히 무엇인가 잘못됐다. 어떤 값으로 초기화된 상수 객체를 하나 만들어 놓고
// 이것에다 상수 멤버 함수를 호출했는데 값이 변해버린 것이다!

// 논리적 상수성이란 개념은 이런 황당한 상황을 보완하는 대체 개념으로 나오게 되었다.
// 논리적 상수성은 상수 멤버 함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라
// 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자측에서 알아채지 못하게만 하면 상수 멤버 자격이
// 있다는 것이다.
// 다음 예를 보자. CTextBlock 클래스는 문장 구역의 길이를 사용자들이 요구할 때마다 이 정보를 캐시해둘 수
// 있을 텐데, 그래서 다음과 같은 멤버를 둘 수 있을 것이다.
class CTextBlock
{
public:
	...
	std::size_t length() const;

private:
	char* pText;
	std::size_t textLength;		// 바로 직전에 계산한 텍스트 길이
	bool lengthIsValid;			// 이 길이가 현재 유효한가?
};

std::size_t CTextBlock::length() const
{
	if (!lengthIsValid)
	{
		textLength = std::strlen(pText);	// 에러! 상수 멤버 함수 안에서는
		lengthIsValid = true;				// textlength 및 lengthIsValid에
	}										// 대입할 수 없다.

	return textlength;
}
// length()의 구현은 너무나도 자명하게 '비트수준 상수성'과 멀리 떨어져 있다.
// textLength 및 lengthIsValid가 바뀔 수 있기 때문이다.
// 그렇지만 CTextBlock의 상수 객체에 대해서는 당연히 아무 문제가 없어야 할 것 같은 코드다.
// 컴파일러는 에러를 쏟아낼 게 뻔하다. 컴파일러의 검열을 통과하려면 비트 수준의 상수성이 지켜져야 한다.
// 이런 상황에서는 어떻게 해야 할까?

// 해답은 단순하다. const에 맞서는 C++의 변신 비기, mutable을 사용하는 것이다.
// mutable은 비정적 데이터 멤버를 비트수준 상수성의 족쇄에서 풀어 주는 키워드 이다.
// 다음을 보자.
class CTextBlock
{
public:
	...
		std::size_t length() const;

private:
	char* pText;
	mutable std::size_t textLength;		// 이 데이터 멤버들은 어떤 순간에도
	mutable bool lengthIsValid;			// 수정이 가능하다. 심지어 상수
};										// 멤버 함수 안에서도 수정할 수 있다.

std::size_t CTextBlock::length() const
{
	if (!lengthIsValid)
	{
		textLength = std::strlen(pText);	// 이제 문제 없다.
		lengthIsValid = true;				// 대입할 수 있다.
	}

	return textlength;
}

// <상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법>
// mutable은 위와 같은 문제를 해결하는 꽤 괜찮은 방법임엔 틀림없지만,
// 이것으로 const에 관련된 골칫거리 전부를 말끔히 씻어내진 못한다.
// 다음의 예를 보자. TextBlock(CTextBlock)의 operator[] 함수가 지금보다
// 훨씬 더 많은 것을 한다고 치자. 경계 검사라던지 접근정보 로깅, 내부자료 무결정 검증 같은 것 말이다.
// 이런저런 코드를 모조리 operator[]의 상수/비상수 버전에 넣어 버리면 어느덧 코드 판박이 괴물이 떡 하니
// 나타날 것이다.
// 다음을 보자.
class TextBlock
{
public:
	...

	const char& operator[](std::size_t position) const
	{
		...							// 경계 검사
		...							// 접근 데이터 로깅
		...							// 자료 무결성 검증
		return text[position];
	}

	char& operator[](std::size_t position)
	{
		...							// 경계 검사
		...							// 접근 데이터 로깅
		...							// 자료 무결성 검증
		return text[position];
	}

private:
	std::string text;
};
// 출석 부르기도 무서운 코드 중복이다. 코드 중복과 함께 꼭 따라 나오는 컴파일 시간, 유지보수,
// 코드 크기 부풀림... 감당할 수 있을까?
// 경계 검사 등의 자질구레한 코드를 별도의 멤버 함수(물론 private멤버로)에 옮겨 두고
// 이것을 operator[]의 양 버전에서 호출하게 만들면 제법 괜찮을 것 같다고 생각하겠지만,
// 그래도 코드 중복은 여전하다. 이렇게 해도 함수 호출이 두 번씩 되기 때문이다.

// 이를 어떻게 해야할까? operator[]의 핵심 기능을 한 번만 구현해 두고 이것을 두 번 사용할 수는
// 없을까? 그러니까, operator[]의 양 버전 중 하나만 제대로 만들고 다른 버전은 이것을 호출하는
// 식으로 만들 수 없을까? 그러면 const 껍데기를 캐스팅으로 날리면 어떨까?

// 기본적으로 캐스팅은 일반적으로도 통념적으로도 썩 좋지 못한 아이디어이다.
// 하지만 코드 중복도 결코 애들 소풍놀이가 아니다.
// 지금의 경우, 두 operator[] 함수는 반환 타입에 const 키워드가 있냐 없냐를 제외하고 하는 일이
// 정확히 똑같다. 따라서 여기서는 캐스팅을 써서 반환 타입으로부터 const 껍데기를 없애더라도 안전하다.
// 왜냐하면 비상수 operator[] 함수를 호출하는 쪽이라면 그 호출부엔 비상수 객체가 우선적으로 들어 있었을 게
// 분명하기 때문이다.
// 그래서 결론은 이렇다. 캐스팅이 필요하긴 하지만, 안전성도 유지하면서 코드 중복을 피하는 방법은 비상수 operator[]가
// 상수 버전을 호출하도록 구현하는 것이다.
// 다음을 보자.
class TextBlock
{
public:
	...

		const char& operator[](std::size_t position) const
	{
		...							// 경계 검사
		...							// 접근 데이터 로깅
		...							// 자료 무결성 검증
		return text[position];
	}

	char& operator[](std::size_t position)		// 상수 버전 op[]를 호출하고 끝
	{
		return const_cast<char&>								// op[]의 반환 타입에 캐스팅을 적용, 
																// const를 떼어낸다.
				
			(static_cast<const TextBlock&>(*this)[position]);	// *this의 타입에 const를 붙인다.
	}															// (op[]의 상수 버전을 호출하기 위해)

private:
	std::string text;
};
// 캐스팅이 한 번이 아니라 두 번인 이유는 다음과 같다. 첫 번째 캐스팅은 *this에 const를 붙이는 캐스팅이다.
// 원래 타입인 TextBlock&에서 const TextBlock&로 바꿔야 상수 버전의 op[]가 호출되기 때문이다.
// 두 번째 캐스팅은 상수 op[]의 반환 값에서 const를 떼어내는 캐스팅이다.

// const를 붙이는 캐스팅은 안전한 타입 변환(비상수 객체에서 상수 객체로 바꾸는)을 강제로 진행하는 것뿐이기 때문에
// static_cast가 괜찮다. 반면에 const를 제거하는 캐스팅은 const_cast밖에 없으므로 다른 선택지가 없다.
// 어쨌든 비상수 멤버 함수의 구현에 상수 멤버 쌍둥이를 사용하는 기법 자체는 꼭 알아둘 가치가 있다.

// 그럼 비상수 -> 상수말고, 상수 -> 비상수는 어떨까?
// 상수 멤버 함수는 해당 객체의 논리적인 상태를 바꾸지 않겠다고 컴파일러와 굳게 약속한 함수인데, 이 함수에서
// const를 떼고 비상수 멤버 함수를 호출하는 것은 틀리다고 할 수 있다. 이것은 위의 경우와 다르게 안전하지 않다.
// 위의 경우가 안전한 이유는 비상수 멤버 함수 안에서는 그 객체를 바꾸든 안 바꾸든 맘대로 할 수 있기 때문에,
// 거기에서 상수 멤버 함수를 호출한다고 해서 특별히 잘못될 리가 없기 때문이다.

// 이것만은 잊지 말자!
// - const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. const는 어떤 유효범위에 있는
// 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있으며, 멤버 함수에도 붙을 수 있다.
// - 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 여러분은 개념적인(논리적인) 상수성을 사용해서
// 프로그래밍해야 한다.
// - 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이
// 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만들자.

/// 항목 4 : 객체를 사용하기 전에 반드시 그 객체를 초기화하자
// 기본제공 타입으로 만들어진 비멤버 객체에 대해서는 초기화를 손수 해야 한다.
// 다음과 같이 말이다.
int x = 0;								// int 직접 초기화
const char* text = "A C-style string";	// 포인터 직접 초기화
double d;								// 입력 스트림에서 읽음으로써
std::cin >> d;							// "초기화" 수행
// 이런 부분을 제외하고 나면, C++의 초기화의 나머지 부분은 생성자로 귀결된다.
// 생성자에서는 그 객체의 모든 것을 초기화하자.
// 또 대입(assignment)을 초기화(initialization)와 헷갈리지 말자.
// 다음 클래스를 보자.
class PhoneNumber
{
public:
	PhoneNumber(const std::string& name, int number);
	PhoneNumber();

private:
	std::string m_Name;
	int m_Number;
};

PhoneNumber::PhoneNumber(const std::string& name, int number)
{
	m_Name = name;		// 지금은 모두 '대입'을 하고 있다.
	m_Number = number;	// '초기화'가 아니다.
}

// C++ 규칙에 의하면 어떤 객체이든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 **전에** 초기화되어야 한다고 명기되어 있다.
// 위의 PhoneNumber 생성자에서는 **대입**을 하고 있는 것이다.
// 대입문 대신에 **멤버 초기화 리스트**를 사용하자.
PhoneNumber::PhoneNumber(const std::string& name, int number)
	: m_Name(name),		// 이제 이들은 모두 '초기화'되고 있다.
	  m_Number(number)
	{ }					// 생성자 본문엔 이제 아무것도 들어가 있지 않다.
// 똑같다고 생각할 수 있지만, 앞의 것보다 더 효율적일 가능성이 크다.
// 앞의 것은 각 멤버 변수들이 기본 생성자를 호출하고 복사 대입 연산자를 연달아 호출한다.
// 하지만 이번에는 복사 생성자를 한 번 호출한다. 대부분의 데이터 타입에 대해서는, 이런 방식이 더 효율적이다.
// 추가적으로 기본 생성자로 초기화하고 싶을 때도 멤버 초기화 리스트를 사용하는 습관을 들이자.
// 다음처럼 말이다.
PhoneNumber::PhoneNumber()
	: m_Name()
	  m_Number(0)
	{ }

// 기본제공 타입의 멤버를 초기화 리스트로 넣는 일이 선택이 아니라 **의무**가 될 때도 있다.
// 상수이거나 참조자로 되어 있는 데이터 멤버의 경우엔 반드시 초기화되어야 한다.
// 상수와 참조자는 대입 자체가 불가능하기 때문이다.

// 따라서 그냥 멤버 초기화 리스트를 항상 사용하는 편이 좋다.
// 대입보다 효율적일 경우가 많기도 하고, 필수적으로 그래야 할 때도 있기 때문이다.

// 현장에서 쓰이는 클래스들 중 상당수가 여러 개의 생성자를 갖고 있다.
// 각 생성자마다 멤버 초기화 리스트가 붙어 있을 것이다.
// 만약 이런 클래스에 데이터 멤버와 기본 클래스가 적지 않게 붙어 있다면, 생성자마다 주렁주렁 매달려 있는
// 멤버 초기화 리스트의 모습은 그리 예쁘게 보이지 않을 것이다. 같은 멤버들이 겹치기 출연하는 것은
// 물론이고(리스트에) 코드도 지겨워진다(프로그래머가 보기에). 이런 경우를 자주 접하게 되어 어떻게라도
// 손을 써야겠다고 느낀다면, 대입으로도 초기화가 가능한 데이터 멤버들을 초기화 리스트에서 빼내어
// 별도의 함수로 옮기는 것도 나쁘지 않다. 이들에 대한 대입 연산을 하나의(대개 private 멤버) 함수에 몰아놓고,
// 모든 생성자에서 이 함수를 호출하게 하는 것이다. 이 방법은 데이터 멤버의 진짜 초기값을 파일에서
// 읽어온다든지 데이터베이스에서 찾아오는 경우에 특히 유용하게 사용할 수 있다. 하지만 일반적인 경우만 따지면
// 대입을 통한 가짜 초기화보다는 멤버 초기화 리스트를 통한 진짜 초기화가 아무래도 좋을 것이다.

// C++에서의 객체 초기화는 꽤나 변덕스럽다는 이야기를 했는데, 이 와중에도 변덕스럽지 않은 부분이 하나 있는데,
// 꼭 알아두어야 한다. 바로 객체를 구성하는 데이터의 초기화 순서이다. 이 순서는 어떤 컴파일러를 막론하고
// 항상 똑같다.
// 1. 기본 클래스는 파생 클래스보다 먼저 초기화된다.
// 2. 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화된다. PhoneNumber를 예로 들면 m_Name이 항상 첫 번째로
// 초기화되고, m_Number가 두 번째로 초기화 된다. 즉, 선언된 순서와 같다. 어쩌다가 멤버 초기화 리스트에 이들이
// 넣어진 순서가 다르더라도 초기화 순서는 그대로이다. 여러분의 코드를 읽는 다른 사람들의 혼동도 막고 '무척이나'
// 찾아내기 힘든 동작 버그도 피하자는 의미에서, 멤버 초기화 리스트에 넣는 멤버들의 순서도 클래스에 선언한 순서와
// 동일하게 맞춰 주도록 하자.

// 다음으로는 '비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다'에 대해서 살펴보자.
// 정적 객체는 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체를 말한다.
// 따라서 스택 객체 및 힙 기반 객체는 애초부터 정적 객체가 될 수 없다.
// 정적 객체의 범주에 들어가는 것은 다음과 같다.
// 1. 전역 객체
// 2. 네임스페이스 유효범위에서 정의된 객체
// 3. 클래스 안에서 static으로 선언된 객체
// 4. 함수 안에서 static으로 선언된 객체
// 5. 파일 유효범위에서 static으로 정의된 객체

// 이들 중 함수 안에 있는 정적 객체는 지역 정적 객체(local static object)라고 한다. (함수에 대해서 지역성을 가지므로)
// 나머지는 비지역 정적 객체(non-local static object)라고 한다.
// 이 다섯 종류의 정적 객체는 프로그램이 끝날 때(main 함수의 실행이 끝날 때) 정적 객체의 소멸자가 호출되며 소멸된다.

// 번역 단위(translation unit)는 컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드를 일컫는다.
// 여기서 번역은 소스의 언어를 기계어로 옮긴다는 의미다.
// 기본적으로는 소스 파일 하나가 되는데, 그 파일이 #include하는 파일(들)까지 합쳐서 하나의 번역 단위가 된다.

// 여기서의 문제는 이렇게 정리된다. 별도로 컴파일된 소스 파일이 두 개 이상 있으며 각 소스 파일에 비지역 정적 객체(전역 객체, 네임스페이스에 있는 객체,
// 클래스 혹은 파일에 있는 정적 객체)가 한 개 이상 들어 있는 경우에 어떻게 되느냐 하는 것이다.
// 그리고 실제적인 문제는 이것이다. 한쪽 번역 단위에 있는 비정적 객체의 초기화가 진행되면서 다른 쪽 번역 단위에 있는 비지역 정적 객체가 사용되는데,
// 불행히도 이 (다른 쪽 번역 단위에 있는) 객체가 초기화되어 있지 않을지도 모른다는 점이다.
// 이유는 위에서 말했듯이, **별개의 번역 단위에서 정의된 비지역 정적 객체들의 초기화 순서는 '정해져 있지 않다'**라는 사실 때문에 그렇다.

// 다음 예제를 보자.
// 인터넷에 있는 파일을 마치 로컬 컴퓨터에 있는 것처럼 보이게 하는 파일 시스템을 나타내는 FileSystem이라는 클래스가 있다고 해보자.
// 이 클래스는 주변의 모든 파일을 단일 파일 시스템처럼 보이게끔 하니까, 아마도 이런 단일 파일 시스템을 나타내는 특수한 객체가 전역 유효범위 혹은
// 네임스페이스 유효범위에 들어 있어야 할 것이다.
class FileSystem					// 여러분의 라이브러리에 포함된 클래스
{
public:
	...
	std::size_t numDisks() const;	// 많고 많은 멤버 함수들 중 하나
	...
};

extern FileSystem tfs;				// 사용자가 쓰게 될 객체
									// "tfs" = "the file system"

// FileSystem 객체가 그리 가볍지 않다는 점은 분위기로 보아 확실하므로,
// 이 클래스로 만든 객체가 초기화되기(생성자가 호출되기) 전에 그 객체를 사용한다는 것은 대재앙을 일으키는 셈일 것이다.

// 이제 이 객체의 사용자 쪽을 살펴보자.
// 파일 시스템 내의 디렉토리를 나타내는 클래스를 사용자가 만들었다고 가정해보자.
// 이 클래스는 tfs를 사용하는 게 자연스러울 것이다.
class Directory						// 라이브러리의 사용자가 만든 클래스
{
public:
	Directory( params );
	...
};

Directory::Directory( params )
{
	...
	size_t disks = tfs.numDisks();	// tfs 객체를 여기서 사용함
	...
}

// 여기서 한 발짝 더 나아가서 가정해보자. 이제는 이 사용자가 Directory 클래스를
// 사용해서 임시 파일을 담는 디렉토리 객체 하나를 생성하기로 마음먹었다.
Directory tempDir( params );	// 임시 파일을 담는 디렉토리
// 정적 객체의 초기화 순서 때문에 문제가 심각해질 수도 있는 상황이 드디어 나타났다.
// tfs가 tempDir보다 먼저 초기화되지 않으면, tempDir의 생성자는 tfs가 초기화되지도 않았는데
// tfs를 사용하려고 할 것이다. 그러나 tfs와 tempDir은 제작자도 다르고 만들어진 시기도 다른데다가
// 소재지(소스 파일)도 다르다. 다시 말해 이들은, 다른 번역 단위 안에서 정의된 비지역 정적 객체이다.
// 어쨌든 tempDir 전에 tfs가 초기화되게 만들고 싶은데, 이 목표를 어떻게 달성할 수 있을까?

// 단언컨대 안 된다. **서로 다른 번역 단위에 정의된 비지역 정적 객체들 사이의 상대적인 초기화 순서는 정해져 있지 않기 때문이다.**

// 한 가지 다행스러운 사실은 설계에 약간의 변화만 살짝 주면 이 문제를 사전에 봉쇄할 수 있다는 점이다.
// 비지역 정적 객체를 하나씩 맡는 함수를 준비하고 이 안에 각 객체를 넣는 것이다.
// 함수 속에서도 이들은 정적 객체로 선언하고, 그 함수에서는 이들에 대한 참조자를 반환하게 만든다.
// 사용자 쪽에서는 비지역 정적 객체를 직접 참조하는 과거의 폐단을 버리고 이제는 함수 호출로 대신한다.
// 정리하자면, '비지역 정적 객체'가 '지역 정적 객체'로 바뀐 것이다. (이것은 싱글턴 패턴의 전형적인 구현양식이다.)

// 지역 정적 객체는 함수 호출 중에 그 객체의 정의에 최초로 닿았을 때 초기화되도록 만들어져 있다.
// 이것은 C++에서 보장하는 사실이며, 위의 방법은 바로 그 사실을 이용한 것이다.
// 따라서 비지역 정적 객체를 직접 접근하지 않고 지역 정적 객체에 대한 참조자를 반환하는 쪽으로 바꾸었다면,
// 여러분이 얻어낸 참조자는 반드시 초기화된 객체를 참조하도록 맞춰 주어야 한다.
// 그리고 비지역 정적 객체 대신에 준비한 '지역 객체 참조자 반환' 함수를 호출할 일이 없다면 해당 객체의 생성/소멸 비용도
// 생기지 않게 막아야 한다.

// 그리하여 tfs와 tempDir에 이 방법을 적용한 결과는 다음과 같다.
class FileSystem { ... };	// 이전과 다를 것 없는 클래스
FileSystem& tfs()			// tfs 객체를 이 함수로 대신한다. 이 함수는
{							// 클래스 안에 정적 멤버로 들어가도 된다.
	static FileSystem fs;	// 지역 정적 객체를 정의하고 초기화한다.
	return fs;				// 이 객체에 대한 참조자를 반환한다.
}

class Directory { ... };	// 역시 이전과 다를 것 없는 클래스
Directory::Directory(params)// 이전과 동일하다. tfs의 참조자 였던 것이
{							// 지금은 tfs()로 바뀌었다는 것만 다르다.
	...
	std::size_t disks = tfs().numDisks();
	...
}

Directory& tempDir()		// tempDir 객체를 이 함수로 대신한다. 이 함수는
{							// Directory 클래스의 정적 멤버로 들어가도 된다.
	static Directory td;	// 지역 정적 객체를 정의/초기화 한다.
	return td;				// 이 객체에 대한 참조자를 반환한다.
}
// 즉, 정적 객체 자체를 직접 사용하지 않고 그 객체에 대한 참조자를 반환하는 것이다.

// 정리하자면, 어떤 객체가 초기화되기 전에 그 객체를 사용하는 일이 생기지 않도록 하려면 딱 세가지만 기억해 두면된다.
// 1. 멤버가 아닌 기본제공 타입 객체는 여러분 손으로 직접 초기화해라.
// 2. 객체의 모든 부분에 대한 초기화에는 멤버 초기화 리스트를 사용하자
// 3. 별개의 번역 단위에 정의된 비지역 정적 객체에 영향을 끼치는 불확실한 초기화 순서를 염두에 두고
// 이러한 불확실성을 피해서 프로그램을 설계해야 한다.

// 이것만은 잊지 말자!
// - 기본제공 타입의 객체는 직접 손으로 초기화한다. 경우에 따라 저절로 되기도 하고 안되기도 하기 때문이다.
// - 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 즐겨 사용하자.
// 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열하자.
// - 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 한다. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.

/// 1장 끝