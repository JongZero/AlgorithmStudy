/// 1장 C++에 왔으면 C++의 법을 따릅시다.
/// 항목 1 : C++를 언어들의 연합체로 바라보는 안목은 필수
// C++를 단일 언어로 바라보는 눈을 넓혀, 상관 관계가 있는 여러 언어들의 연합체(federation)으로 보자.
// C++를 제대로 따라잡으려면, 이 언어가 여러 개의 하위 언어(sublanguage)를 제공한다는 점을 새기고 있어야 한다.
// 하위 언어는 아래의 네 가지이다.
// C : C++는 여전히 C를 기본으로 하고 있다. 블록, 문장, 선행 처리자, 기본제공 데이터타입, 배열, 포인터 등
// 모든 것이 C에서 왔다.
// 객체 지향 개념의 C++ : 이 부분에 '클래스를 쓰는 C'에 관한 것이 모두 해당된다.
// 그러니까 클래스(생성자와 소멸자 개념까지), 캡슐화, 상속, 다형성, 가상 함수(동적 바인딩)등이다.
// 템플릿 C++ : C++의 일반화 프로그래밍 부분이다. 템플릿의 주체 못할 강력함이 너무나도 크고 훌륭하다 보니
// 완전히 새로운 프로그래밍 패러다임이 파생되기까지 했다. 이름하여 템플릿 메타프로그래밍(template metaprogramming: TMP)이다.
// STL : STL은 이름에서 알 수 있듯이 템플릿 라이브러리이다. 하지만 대단히 특별한 템플릿 라이브러리라고 말할 수 있다.
// STL의 세계는 컨테이너(container), 반복자(iterator), 알고리즘(algorithm)과 함수 객체(function object)가 만수산 드렁칡처럼
// 얽혀 돌아가는 것을 규칙으로 삼고 있으나, 템플릿과 라이브러리는 얼마든지 다른 아이디어를 중심으로 만들어질 수 있다. 또한 STL은
// 나름대로 독특한 사용규약이 있어서, STL을 써서 프로그래밍하려면 그 규약을 따르면 된다.

// 이것만은 잊지 말자!
// C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라진다.
// 그 경우란, 바로 C++의 어떤 부분을 사용하느냐이다.

/// 항목 2 : #define을 쓰려거든 const, enum, inline을 떠올리자
// "가급적 선행 처리자보다 컴파일러를 더 가까이 하자"

// 아래와 같은 코드를 썼다고 가정해보자.
#define ASPECT_RATIO 1.653
// 우리에겐 ASPECT_RATIO가 기호식 이름(symbolic name)으로 보이지만 컴파일러에겐 전혀 보이지 않는다.
// 컴파일러에게 넘어가기 전에 선행 처리자가 밀어버리고 숫자 상수로 바꾸어 버리기 때문이다.
// 그 결과로, ASPECT_RATIO라는 이름은 컴파일러가 쓰는 기호 테이블에 들어가지 않는다.
// 그래서 숫자 상수로 대체된 코드에서 컴파일 에러라도 발생하게 되면 꽤나 헷갈릴 수 있다.
// 소스 코드엔 분명히 ASPECT_RATIO가 있었는데 에러 메시지엔 1.653이 있으니깐 말이다.

// 이런 문제의 해결법은 매크로 대신 상수를 쓰는 것이다.
const double AspectRatio = 1.653;	// 대문자로만 표기하는 이름은 대개 매크로에 쓰는 것이어서,
									// 이름 표기도 바꾼다.
// AspectRatio는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 당연히 컴파일러의 눈에도 보이며
// 기호 테이블에도 당연히 들어간다.
// 게다가 (위의 예제처럼) 상수가 부동소수점 실수 타입일 경우에는 컴파일을 거친 최종 코드의 크기가 #define을 썼을 때보다
// 작게 나올 수 있다.
// 매크로를 쓰면 코드에 ASPECT_RATIO가 등장하기만 하면 선행 처리자에 의해 1.653으로 모두 바뀌면서 결국
// 목적 코드 안에 1.653의 사본이 등장 횟수만큼 들어가게 되지만, 상수 타입의 AspectRatio는 아무리 여러 번 쓰이더라도
// 사본은 딱 한 개만 생기기 때문이다.

// #define을 상수로 교체할 때는 다음을 특별히 조심하자.
// 상수 포인터(constant pointer)를 정의하는 경우
// 상수 정의는 대개 헤더 파일에 넣는 것이 상례이므로(다른 소스 파일이 이것을 인클루드해서 쓰게 되므로) 포인터(pointer)는 꼭
// const로 선언해 주어야 하고, 이와 아울러 포인터가 가리키는 대상까지 const로 선언하는 것이 보통이다.
// 이를테면 어떤 헤더 파일 안에 char* 기반의 문자열 상수를 정의한다면 다음과 같이 const를 **두 번** 써야 한다는 말이다.
// const와 포인터가 함께 쓰일 경우에 대한 내용은 항목 3을 참고하자.
const char* const authorName = "Scott Meyers";

#include <string>
// 문자열 상수를 쓸 때 위와 같이 char* 기반의 구닥다리 문자열보다는 string 객체가 대체적으로 사용하기 괜찮다.
//const std::string authorName("Scott Meyers");

// 2. 클래스 멤버로 상수를 정의하는 경우, 즉 클래스 상수를 정의하는 경우
// 어떤 상수의 유효범위를 클래스로 한정하고자 할 때는 그 상수를 멤버로 만들어야 하는데,
// 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 정적(static) 멤버로 만들어야 한다.
// 다음을 보자.
//class GamePlayer
//{
//private:
//	static const int NumTurns = 5;		// 상수 선언
//	int scores[NumTurns];				// 상수를 사용하는 부분
//};

// 다음도 가능하다.
class GamePlayer
{
private:
	enum { NumTurns = 5 };		// "나열자 둔갑술" : NumTurns를
								// 5에 대한 기호식 이름으로 만든다.

	int scores[NumTurns];		// 사용하는 부분
};
// 위와 같은 방법을 '나열자 둔갑술(enum hack)'이라고 부른다.
// 나열자 둔갑술은 알아 두는 것이 2가지 이유로 피가 되고 살이 된다.
// 1. 나열자 둔갑술은 동작 방식이 const보다는 #define에 더 가깝다.
// 여러분이 선언한 정수 상수를 가지고 다른 사람이 주소를 얻는다든지
// 참조자를 쓴다든지 하는 것이 싫다면 enum이 아주 좋은 자물쇠가 될 수 있다.
// enum은 #define처럼 어떤 형태의 쓸데없는 메모리 할당도 절대 저지르지 않는다.

// 2. 실용적인 이유로, 상당히 많은 코드에서 이 기법이 쓰이고 있기 때문에 알면 좋다.
// 이 나열자 둔갑술은 템플릿 메타프로그래밍의 핵심 기법이기도 하다. (항목 48 참조)

// 다음은 매크로 함수를 보자.
// 매크로 함수는 함수처럼 보이지만 함수 호출 오버헤드를 일으키지 않는 매크로다.
// 다음의 예를 보자. 매크로 인자들 중 큰 것을 사용해서 어떤 함수 f를 호출하는 매크로다.
// a와 b 중에 큰 것을 f에 넘겨 호출한다.
#define CALL_WITH_MAX(a, b) int f((a) > (b) ? (a) : (b))
// 이런 식의 매크로는 단점이 한두 개가 아니다.
// 이런 매크로를 작성할 때는 매크로 본문에 들어 있는 인자마다 반드시 괄호를 씌워 주는 센스를 잊지 말아야 한다.
// 이게 안 되어 있으면, 표현식을 매크로에 넘길 때 골치 아픈 일이 발생할 수 있다.
// 그런데 이 부분을 제대로 처리한다고 해서 끝난 것일까? 괴현상을 일으키는 다음 예를 보자.
//int a = 5, b = 0;
//CALL_WITH_MAX(++a, b);			// a가 두 번 증가한다.
//CALL_WITH_MAX(++a, b + 10);		// a가 한 번 증가한다.
// f가 호출되기 전에 a가 증가하는 횟수가 달라진다.
// 비교를 통해 처리한 결과가 어떤 것이냐에 따라 달라지는 것이다.

// C++에서는 함수 호출을 없애 준다는 명목 하에 자행되는 이런 어처구니없는 작태를 참을 필요가 없다.
// 기존 매크로의 효율을 그대로 유지함은 물론 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽히 취할 수 있는 방법이
// 있기 때문이다.
// 바로, 인라인 함수에 대한 템플릿을 준비하는 것이다.
template<typename T>								// T가 정확히 무엇인지
inline void callWithMax(const T& a, const T& b)		// 모르기 때문에, 매개변수로
{													// 상수 객체에 대한 참조자를
	f(a > b ? a : b);								// 쓴다. 항목 20 참조
}
// 이 함수는 템플릿이기 때문에 동일 계열 함수군(family of functions)을 만들어낸다.
// 동일한 타입의 객체 두 개를 인자로 받고 둘 중 큰 것을 f에 넘겨서 호출하는 구조다.
// 보면 알겠지만 함수 본문에 괄호로 분칠을 해 댈 필요가 없고, 인자를 여러 번 평가할지도
// 모른다는 걱정도 없어진다. 그뿐 아니라 callWithMax는 진짜 함수이기 때문에 유효범위 및
// 접근 규칙을 그대로 따라간다.

// 이것만은 잊지 말자!
// - 단순한 상수를 쓸 때는, #define보다 const 객체 혹은 enum을 우선 생각하자
// - 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각하자.

/// 항목3 : 낌새만 보이면 const를 들이대 보자!
// const의 면모에 대해 생각해 볼 때 정말 멋지다고 말할 수 있는 부분이 있다면 아마도
// '의미적인 제약'(const가 붙은 객체는 외부 변경을 **불가능**하게 한다)을 소스 코드 수준에서
// 붙인다는 점과 컴파일러가 이 제약을 단단히 지켜준다는 점일 것이다.
// 어떤 값(객체의 내용)이 불변이어야 한다는 제작자의 의도를 컴파일러 및 다른 프로그래머와 나눌 수 있는
// 수단이라고나 할까?

// const 키워드는 그야말로 팔방미인이다.
// 클래스 바깥에서는 전역 혹은 네임스페이스 유효범위의 상수를 선언(정의)하는 데 쓸 수 있다.
// 그뿐 아니라 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const를 붙일 수 있다.
// 클래스 내부의 경우에는, 정적 멤버 및 비정적 데이터 멤버 모두를 상수로 선언할 수 있다.

// 포인터는 어떨까? 기본적으로 포인터 자체를 상수로, 혹은 포인터가 가리키는 데이터를 상수로
// 지정할 수 있는데, 둘 다 지정할 수도 있고 아무것도 지정하지 않을 수도 있다.
// 다음을 보자.
char greeting[] = "Hello";

char* p = greeting;					// 비상수 포인터,
									// 비상수 데이터

const char* p = greeting;			// 비상수 포인터,
									// 상수 데이터

char* const p = greeting;			// 상수 포인터,
									// 비상수 데이터

const char* const p = greeting;		// 상수 포인터,
									// 상수 데이터
// const 키워드가 *표의 왼쪽에 있으면 포인터가 가리키는 대상이 상수인 반면,
// const가 *표의 오른쪽에 있는 경우엔 포인터 자체가 상수다. const가 *표의 양쪽에
// 다 있으면 포인터가 가리키는 대상 및 포인터가 다 상수라는 뜻이다.

struct Widget {};

// 아래의 함수들이 받아들이는 매개변수 타입은 모두 똑같다.
void f1(const Widget* pw);		// f1은 상수 Widget 객체에 대한
								// 포인터를 매개변수로 취한다.
void f2(Widget const* pw);		// f2도 마찬가지다.

// STL 반복자(iterator)는 포인터를 본뜬 것이기 때문에,
// 기본적인 동작 원리가 T* 포인터와 매우 흡사하다.
// 어떤 반복자를 const로 선언하는 일은 포인터를 상수로 선언하는 것(즉, T* const 포인터)과 같다.
// 반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않지만,
// 반복자가 가리키는 대상 자체는 변경이 가능하다. 만약 변경이 불가능한 객체를 가리키는 반복자
// (즉, const T* 포인터의 STL 대응물)가 필요하다면 const_iterator를 쓰면 된다.
#include <vector>


int main()
{
	std::vector<int> vec;
	const std::vector<int>::iterator iter = vec.begin();

	for (const std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++)
	{
		*it = 10;
		++it;
	}

	for (auto it : vec)
	{
		it = 10;
	}

	// iter는 T* const처럼 동작한다.
	*iter = 10;		// OK, iter가 가리키는 대상을 변경한다.
	++iter;			// 에러! iter는 상수다.

	std::vector<int>::const_iterator cIter = vec.begin();
	// cIter는 const T*처럼 동작한다.
	*cIter = 10;	// 에러! *cIter가 상수이기 때문에 안된다.
	++cIter;		// 이건 문제없다. cIter를 변경하기 때문
}







#include <iostream>
using namespace std;
int main()
{
	int a = 5, b = 0;
	CALL_WITH_MAX(++a, b + 10);			// a가 두 번 증가한다.

	cout << a << '\n';
	cout << b;

	//CALL_WITH_MAX(++a, b + 10);		// a가 한 번 증가한다.


}