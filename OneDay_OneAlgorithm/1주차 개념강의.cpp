// 입력
// 수의 개수 N, 합을 구해야하는 횟수 M, 그 이후 N개의 수가 주어진다.
// 수는 100이하의 자연수, 그 이후 M개의 줄에는 합을 구해야 하는 구간 A, B가 주어진다.

// 출력
// M개의 줄에 A, B까지의 합을 구하라.

// 범위
// 1 <= N <= 100,000
// 1 <= M <= 100,000
// 1 <= A <= B <= N

// 예제 입력
// 8 3
// 1 2 3 4 5 6 7 8
// 1 4
// 1 5
// 3 5

// 예제 출력
// 10
// 15
// 12

#include <bits/stdc++.h>
using namespace std;
int main2()
{
	int n = 8;
	int m = 3;
	vector<int> input = { 0,  1,2,3,4,5,6,7,8 };
	vector<pair<int, int>> ab = { {1, 4}, {1, 5}, {3, 5} };

	vector<int> sums(n + 1);
	int sum = 0;
	for (int i = 1; i < n + 1; i++)
	{
		sum += input[i];
		sums[i] = sum;
	}

	for (int i = 0; i < m; i++)
	{
		int a, b;
		tie(a, b) = ab[i];

		cout << sums[b] - sums[a - 1];
		cout << '\n';
	}

	return 0;
}
// 누적합을 만들 때는 반드시 "1번째 요소부터" 만드는 것이 좋다. 왜냐면 i - 1 이 부분이 있기 때문에 i가 0이면 -1이 되기 때문이다.


// 구간쿼리 : 정적배열 / 동적배열
//			  구간합		트리(세그먼트트리, 펜윅트리)


// 구현
string dopa = "life is limited";

int main()
{
	// Q1. 앞에서 3개의 문자열을 뽑아내라.
	cout << dopa.substr(0, 3) << '\n';
	// Q2. 거꾸로해서 출력하라.
	reverse(dopa.begin(), dopa.end());
	cout << dopa << '\n';
	// Q3. 거꾸로 한다음 그 이후에 dopa!!를 추가해라.
	cout << dopa + "dopa!!";

	return 0;
}

// 문제를 푸는 방법
// 1. 문제를 본다.
// 2. 문제를 해석한다.
// 3. 코드를 작성한다.

// 크게 3가지의 과정을 통해서 문제를 풀게 된다.
// 여기서 중요한 점은
// 2번 문제를 해석하는 것이다.
// 문제를 처음에 봤을 때 이러한 일련의 생각들이 일어나야 한다.
// 1. 최대, 최소 범위를 파악한다.
// 2. 무식하게 for문이나 재귀를 통해 풀 수 있는가?
// 3. 이걸 푸는 최적해가 있을까?
// 4. 단순 구현이라면 어떠한 반례가 있을까?
// 5. 단순구현이 아니고 다른 최단거리, 유니온파인드 등의
// 문제라면 어떻게 풀어야 하는가?


// 1-G 
// string의 substr에서
string s = "aaahello";
string ss = s.substr(3);
// 위처럼 두번째 인자를 비워놓으면 3번 인덱스부터 끝까지 알아서 자른다.


// 1-J
// 경우의 수인 경우 숫자가 매우 커질 수 있음
// -> long long을 박고 시작하자.


// 1-M
// 문제를 보고 잘 모르겠으면 90도 회전시켜보고, 반대로 뒤집어보고, 뒤에 더 추가해보자.
// ex. ABAB ->	B	, BABA, ABABABAB
//				A
//				B
//				A
// 짝짓기, 폭발 -> Stack 고려.